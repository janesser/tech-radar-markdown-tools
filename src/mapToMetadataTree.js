/**
 * @file Utility functions for mapping a structured tree of
 * markdown tokens to rendered markdown with metadata
 * @author David Garner
 */

const marked = require('marked');

require('./typedef');

/**
 * Converts an array of marked tokens into a metadata object and the rendered
 * HTML of that section.
 *
 * @param {Links} links The markdown links data object generated by `marked`
 * @param {Token[]} tokens  An array of marked lexer tokens in a section
 * @returns {[Metadata, string]} A tuple with the metadata object and rendered
 * HTML of the section
 */
function parseSectionTokens(links, tokens) {
  const metadata = {};
  const listStart = tokens.findIndex(token => token.type === 'list_start');
  const listEnd = tokens.findIndex(token => token.type === 'list_end');
  for (let i = listStart; i < listEnd; i++) {
    if (tokens[i].type === 'text') {
      let [key, value] = tokens[i].text.split(':').map(t => t.trim());
      if (value) {
        metadata[key.toLowerCase()] = value;
      }
    }
  }
  const markedTokens = tokens.slice(listEnd + 1);
  let content = '';
  if (markedTokens.length) {
    markedTokens.links = links;
    content = marked.parser(markedTokens).trim();
  }

  return [metadata, content];
}

/**
 * Maps a tree of section nodes with `marked` tokens and nested subsections to a
 * tree of metadata nodes, each of which contains rendered HTML, metadata, and
 * subsections.
 *
 * @param {Links} links The markdown links data object generated by `marked`
 * @param {SectionNode} sectionNode The section node to map to a metadata node
 * @returns {MetadataNode} The resulting metadata-decorated node
 */
function mapToMetadataTree(links, sectionNode) {
  const { name, tokens, sections } = sectionNode;
  const [metadata, content] = parseSectionTokens(links, tokens);
  let mappedSections;
  if (sections) {
    mappedSections = sections.map(section => mapToMetadataTree(links, section));
  }
  return { name, metadata, content, sections: mappedSections };
}

module.exports = mapToMetadataTree;
