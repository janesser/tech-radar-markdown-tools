/**
 * @file Utility functions for mapping a structured tree of
 * markdown tokens to rendered markdown with metadata
 * @author David Garner
 */

const marked = require('marked');

/**
 * A markdown token object returned by marked lexer parse
 * @typedef {Object} Token
 * @property {type} string - The type of the token.
 */

/**
 * A map of link keys and values used by the `marked` Markdown parser
 * @typedef {Object} Links
 */

/**
 * The metadata object of a section.
 * @typedef {Object.<string, string>} Metadata
 */

/**
 * A tree node representing a section with nested subsections
 * @typedef {Object} SectionNode
 * @property {string} name - The name of the section
 * @property {Token[]} tokens - An array of marked lexer tokens. This represents
 * the markdown appearing after the section heading but before any subsection
 * headings.
 * @property {SectionNode[]=} sections - The subsections of this section
 */

/**
 * A tree node representing a section with metadata, rendered content, and
 * nested subsections
 * @typedef {Object} MetadataNode
 * @property {string} name - The name of the section
 * @property {Metadata} metadata - An object of metadata for the section
 * @property {string} content - The rendered HTML content of this node
 * @property {MetadataNode[]=} sections - The subsections of this section
 */

/**
 * Converts an array of marked tokens into a metadata object and the rendered
 * HTML of that section.
 *
 * @param {Links} links The markdown links data object generated by `marked`
 * @param {Token[]} tokens  An array of marked lexer tokens in a section
 * @returns {[Metadata, string]} A tuple with the metadata object and rendered
 * HTML of the section
 */
function parseSectionTokens(links, tokens) {
  const metadata = {};
  const listStart = tokens.findIndex(token => token.type === 'list_start');
  const listEnd = tokens.findIndex(token => token.type === 'list_end');
  for (let i = listStart; i < listEnd; i++) {
    if (tokens[i].type === 'text') {
      let [key, value] = tokens[i].text.split(':').map(t => t.trim());
      if (value) {
        metadata[key.toLowerCase()] = value;
      }
    }
  }
  const markedTokens = tokens.slice(listEnd + 1);
  let content = '';
  if (markedTokens.length) {
    markedTokens.links = links;
    content = marked.parser(markedTokens).trim();
  }

  return [metadata, content];
}

/**
 * Maps a tree of section nodes with `marked` tokens and nested subsections to a
 * tree of metadata nodes, each of which contains rendered HTML, metadata, and
 * subsections.
 *
 * @param {Links} links The markdown links data object generated by `marked`
 * @param {SectionNode} sectionNode The section node to map to a metadata node
 * @returns {MetadataNode} The resulting metadata-decorated node
 */
function mapToMetadataTree(links, sectionNode) {
  const { name, tokens, sections } = sectionNode;
  const [metadata, content] = parseSectionTokens(links, tokens);
  let mappedSections;
  if (sections) {
    mappedSections = sections.map(section => mapToMetadataTree(links, section));
  }
  return { name, metadata, content, sections: mappedSections };
}

module.exports = mapToMetadataTree;
